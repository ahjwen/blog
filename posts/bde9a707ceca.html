<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta name="msvalidate.01" content="179D15F7BD0D95DD2CC91714BFACD3CC"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JWT 入门 | GivenSir`Blog</title><meta name="keywords" content="JWT"><meta name="author" content="GivenSir"><meta name="copyright" content="GivenSir"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JWT 入门 JWT 超详细分析 https:&#x2F;&#x2F;learnku.com&#x2F;articles&#x2F;17883  一、什么是 jwt ?二、JWT 的组成和优势JWT 全称 JSON Web Tokens ，是一个非常轻巧的规范。这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。它的两大使用场景是：认证和数据交换。 1. 组成一个 JWT token 是一个字符串，它由三部分组成，头部、">
<meta property="og:type" content="article">
<meta property="og:title" content="JWT 入门">
<meta property="og:url" content="https://blog.givensir.cn/posts/bde9a707ceca.html">
<meta property="og:site_name" content="GivenSir&#96;Blog">
<meta property="og:description" content="JWT 入门 JWT 超详细分析 https:&#x2F;&#x2F;learnku.com&#x2F;articles&#x2F;17883  一、什么是 jwt ?二、JWT 的组成和优势JWT 全称 JSON Web Tokens ，是一个非常轻巧的规范。这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。它的两大使用场景是：认证和数据交换。 1. 组成一个 JWT token 是一个字符串，它由三部分组成，头部、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2021-12-09T01:06:01.913Z">
<meta property="article:modified_time" content="2021-12-09T01:06:01.913Z">
<meta property="article:author" content="GivenSir">
<meta property="article:tag" content="JWT">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.givensir.cn/posts/bde9a707ceca"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JWT 入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-09 09:06:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/static.css"><meta name="generator" content="Hexo 5.4.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://givensir.oss-cn-hangzhou.aliyuncs.com/logo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类页</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">GivenSir`Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类页</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout hide-aside" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JWT 入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-09T01:06:01.913Z" title="发表于 2021-12-09 09:06:01">2021-12-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-09T01:06:01.913Z" title="更新于 2021-12-09 09:06:01">2021-12-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JWT 入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="JWT-入门"><a href="#JWT-入门" class="headerlink" title="JWT 入门"></a>JWT 入门</h1><ul>
<li>JWT 超详细分析 <a target="_blank" rel="noopener" href="https://learnku.com/articles/17883">https://learnku.com/articles/17883</a></li>
</ul>
<h2 id="一、什么是-jwt"><a href="#一、什么是-jwt" class="headerlink" title="一、什么是 jwt ?"></a>一、什么是 jwt ?</h2><h2 id="二、JWT-的组成和优势"><a href="#二、JWT-的组成和优势" class="headerlink" title="二、JWT 的组成和优势"></a>二、JWT 的组成和优势</h2><p><strong>JWT</strong> 全称 <strong>JSON Web Tokens</strong> ，是一个非常轻巧的规范。这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。它的两大使用场景是：认证和数据交换。</p>
<h3 id="1-组成"><a href="#1-组成" class="headerlink" title="1. 组成"></a>1. 组成</h3><p>一个 JWT token 是一个字符串，它由三部分组成，头部、载荷与签名，中间用 <code>.</code> 分隔，例如：<code>xxxxx.yyyyy.zzzzz</code>。</p>
<h4 id="头部（header）"><a href="#头部（header）" class="headerlink" title="头部（header）"></a>头部（header）</h4><p>头部通常由两部分组成：令牌的类型（即 JWT）和正在使用的签名算法（如 HMAC SHA256 或 RSA.）。</p>
<p>例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后用 <code>Base64Url</code> 编码得到头部，即 <code>xxxxx</code>。</p>
<h4 id="载荷（Payload）"><a href="#载荷（Payload）" class="headerlink" title="载荷（Payload）"></a>载荷（Payload）</h4><p>载荷中放置了 <code>token</code> 的一些基本信息，以帮助接受它的服务器来理解这个 <code>token</code>。同时还可以包含一些自定义的信息，用户信息交换。</p>
<p>载荷的属性也分三类：</p>
<blockquote>
<ul>
<li><p>预定义（Registered）</p>
</li>
<li><p>公有（public）</p>
</li>
<li><p>私有（private）</p>
</li>
</ul>
</blockquote>
<h5 id="预定义的载荷"><a href="#预定义的载荷" class="headerlink" title="预定义的载荷:"></a>预定义的载荷:</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iss&quot;</span>: <span class="string">&quot;http://localhost:8000/auth/login&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>: <span class="number">1451888119</span>,</span><br><span class="line">  <span class="attr">&quot;exp&quot;</span>: <span class="number">1454516119</span>,</span><br><span class="line">  <span class="attr">&quot;nbf&quot;</span>: <span class="number">1451888119</span>,</span><br><span class="line">  <span class="attr">&quot;jti&quot;</span>: <span class="string">&quot;37c107e4609ddbcc9c096ea5ee76c667&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;aud&quot;</span>: <span class="string">&quot;dev&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面的前 7 个字段都是由官方所定义的，也就是预定义（Registered claims）的，并不都是必需的。</p>
<blockquote>
<ul>
<li>iss (issuer)：签发人</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>exp (expiration time)：过期时间</li>
<li>nbf (Not Before)：生效时间，在此之前是无效的</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
</blockquote>
<h5 id="公有的载荷"><a href="#公有的载荷" class="headerlink" title="公有的载荷"></a>公有的载荷</h5><p>在使用 JWT 时可以额外定义的载荷。为了避免冲突，应该使用 <a target="_blank" rel="noopener" href="https://www.iana.org/assignments/jwt/jwt.xhtml">IANA JSON Web Token Registry</a> 中定义好的，或者给额外载荷加上类似命名空间的唯一标识。</p>
<h5 id="私有载荷"><a href="#私有载荷" class="headerlink" title="私有载荷"></a>私有载荷</h5><p>在信息交互的双方之间约定好的，既不是预定义载荷也不是公有载荷的一类载荷。这一类载荷可能会发生冲突，所以应该谨慎使用。</p>
<p>将上面的 <code>json</code> 进行 <code>Base64Url</code> 编码得到载荷，，即 <code>yyyyy</code>。</p>
<blockquote>
<p>关于载荷的理解：</p>
<p>这里三种载荷的定义应该明确的一点是 —— 对于后两种载荷，它并非定义了载荷的种类，然后让你去选用哪种载荷，而是对你可能会定义出来的载荷做一个分类。</p>
<p>比如你定义了一个 <code>admin</code> 载荷，这个载荷按其分类应该是私有载荷，可能会和其他人定义的发生冲突。但如果你加了一个前缀（命名空间），如 <code>namespace-admin</code>，那么这应该就算一个公有载荷了。（但其实标准并没有定义怎么去声明命名空间，所以严格来说，还是可能会冲突）</p>
<p>但是在现实中，团队都是约定好的了要使用的载荷，这样的话，好像根本不存在冲突的可能。那为什么文档要这么定义呢？我的理解是，RFC 是提出一种技术规范，出发点是一套通用的规范，考虑的范围是所有开发者，而不仅仅局限于一个开发者团队。就像用 token 做认证已经是很常见的技术了，但是 JWT 的提出就相当于提出了一套较为通用的技术规范。既然是为了通用，那么考虑在大环境下的冲突可能性也是必须的。</p>
</blockquote>
<h5 id="签名（Signature）"><a href="#签名（Signature）" class="headerlink" title="签名（Signature）"></a>签名（Signature）</h5><p>签名时需要用到前面编码过的两个字符串，如果以 <code>HMACSHA256</code> 加密，就如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">    base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">    base64UrlEncode(payload),</span><br><span class="line">    secret</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>加密后再进行 <code>base64url</code> 编码最后得到的字符串就是 <code>token</code> 的第三部分 <code>zzzzz</code>。</p>
<p>组合便可以得到 <code>token：xxxxx.yyyyy.zzzzz</code>。</p>
<p>签名的作用：保证 JWT 没有被篡改过，原理如下：</p>
<blockquote>
<p>HMAC 算法是不可逆算法，类似 MD5 和 hash ，但多一个密钥，密钥（即上面的 secret）由服务端持有，客户端把 token 发给服务端后，服务端可以把其中的头部和载荷再加上事先共享的 secret 再进行一次 HMAC 加密，得到的结果和 token 的第三段进行对比，如果一样则表明数据没有被篡改。</p>
<p><strong>Hash-based Message Authentication Code</strong></p>
</blockquote>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><p>JWT 的使用有两种方式：</p>
<ul>
<li>加到 url 中：<code>?token=你的token</code></li>
<li>加到 header 中，建议用这种，因为在 https 情况下更安全：<code>Authorization:Bearer 你的token</code></li>
</ul>
<p>JWT 在客户端的存储有三种方式：</p>
<ul>
<li>LocalStorage</li>
<li>SessionStorage</li>
<li>Cookie [不能设置 HTTPonly]</li>
</ul>
<p>但是最推荐的还是第三种，因为第一二种存在跨域读取限制，而 Cookie 使用不同的跨域策略。</p>
<blockquote>
<p>因为没开 HTTPonly，所以要注意防范 XSS 漏洞。</p>
</blockquote>
<h4 id="Cookie-的跨域策略"><a href="#Cookie-的跨域策略" class="headerlink" title="Cookie 的跨域策略"></a>Cookie 的跨域策略</h4><p>子可以读父，但是父不可以读子，兄弟之间不能互相访问。</p>
<p>a.xxx.com 和 b.xxx.com 可以读 xxx.com，但是 a.xxx.com 和 b.xxx.com 不能互相读取，xxx.com 也不能读 a.xxx.com 和 b.xxx.com 的。</p>
<blockquote>
<p>你可能会想：存 Cookie 那我不是又变得和 cookie + session 一样了吗？</p>
<p>其实不然，因为存 cookie 在这只是用到了其存储机制，而没有利用其去鉴权。也就是说我只是简单存一下，并没有期望浏览器带上去 token 去鉴权，将 token 加入请求这部分操作还是我手动进行的。</p>
</blockquote>
<h3 id="3-相对于一般-token-的优点"><a href="#3-相对于一般-token-的优点" class="headerlink" title="3. 相对于一般 token 的优点"></a>3. 相对于一般 token 的优点</h3><p>既然 JWT 也是一种 token，那么它相对于普通的 token 有何优点呢？</p>
<h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>因为 JWT 的有效期完全与其载荷中编码的过期时间，服务端不维护任何状态，因此 JWT 『一般』是『无状态』的（为什么是一般，后面会仔细说）。无状态最大的优势在于三点：</p>
<ul>
<li>节省服务器的资源：因为服务端无需维护一个状态，因此能够节省服务端原先保存这些状态所花费的资源</li>
<li>适合分布式：因为服务端无需维护状态，因此如果服务端是多台服务器组成的分布式集群，那么无需像『有状态』一样互相同步各自的状态。</li>
<li>时间换空间：因为 token 的校验时通过签名校验来进行的，签名校验消耗的是 CPU 时间，而『有状态』是需要通过客户端提供的凭据对服务端现有的状态进行一次查询，消耗的是 I/O 和内存、磁盘空间。通常对于一个 Web 服务来说，其属于 I/O 密集型，因此通过时间换空间这一操作，可以提高整体的硬件使用率。</li>
</ul>
<h4 id="编码数据"><a href="#编码数据" class="headerlink" title="编码数据"></a>编码数据</h4><p>因为 JWT 能够在载荷中编码了部分信息，所以如果把常用数据编码进去的话，能够大大减少数据库的查询次数，不过有两点需要额外注意的：</p>
<ul>
<li>载荷信息是明文编码的，所以不能编码敏感信息在里面，如果要编码可以先加密再编码进去</li>
<li>token 在每次请求时都会进行传输，所以载荷中不能编码过多的信息，否则会降低传输效率</li>
</ul>
<blockquote>
<p>所以 JWT 就有四个优点了：</p>
<ul>
<li>防 CSRF</li>
<li>适合移动应用</li>
<li>无状态</li>
<li>编码数据</li>
</ul>
<p>前两个是 token 的优势，后两个是 JWT 独特的优势。</p>
</blockquote>
<h2 id="三、JWT-的安全问题"><a href="#三、JWT-的安全问题" class="headerlink" title="三、JWT 的安全问题"></a>三、JWT 的安全问题</h2><p>既然主要使用场景是鉴权，那么安全问题就是不得不考虑的问题了。下面对 JWT 可能需要的安全问题都进行一次深入的探讨并寻求最佳的解决方案。</p>
<h3 id="1-重放攻击"><a href="#1-重放攻击" class="headerlink" title="1. 重放攻击"></a>1. 重放攻击</h3><p>重放攻击是通过把原先的包进行一次重放来进行攻击的手段。需要先明确是的 cookie + session 也是存在重放攻击的问题的。</p>
<p>常用的防范重放攻击的措施主要有以下几种：</p>
<ul>
<li><p>timestamp</p>
<p>​    在请求中夹带一个时间戳，设置较短的有效期，如果一个新来的请求的请求时间超过了请求中的有效期，则认为无效。但是这种策略也存在问题，即如果一个黑客『眼疾手快』在有效期以内将你的包进行了重放， 那就来攻击成功。</p>
<p>这种策略对应到 JWT 中就是给 token 设置一个较短的有效期。</p>
</li>
<li><p>nonce</p>
<p>​    在请求中夹带一个随机字符串，这个字符串传送到客户端后即存入客户端的黑名单中，如果一个新来的请求其中存在的随机字符串已经在黑名单中则认为无效。但是显然，这个策略存在巨大的问题：服务端需要维护一个黑名单库，这个库的大小会随着业务运行的时间而变得无比巨大，从而严重影响效率。</p>
<p>​    这种策略对应到 JWT 中就是给 token 设置一个黑名单，但是不设置有效期。</p>
</li>
<li><p>timestamp + nonce</p>
<p>​    在请求中夹带一个随机字符串和一个时间戳，如果一个新来的请求，其随机字符串已经在黑名单中则认为无效，或者一个请求的的请求时间超过了其有效期，则也认为其无效。这样黑名单的范围只需设置为时间戳策略的有效期范围即可。</p>
<p>​    这种策略对应到 JWT 中就是给 token 既设置一个黑名单，又设置一个有效期。</p>
</li>
<li><p>挑战 - 应答</p>
<p>​    这个其实和 <strong>timestamp + nonce</strong> 策略一样，只是随机字符串是有服务端生成给客户端的，客户端携带服务端所给的随机串来请求。这样有什么好处呢？服务端可以通过一个加密算法来生成这个串，使其和时间戳相关，同时客户端又无法伪造。这样就不需要维护黑名单了。同样也是时间换空间的策略。但是显然每次或几次请求就要进行一次与预请求以得到随机串，并不是特别方便，造成的额外消耗也有待考量。</p>
</li>
<li><p>序列号</p>
<p>​    通过在请求中嵌入一个序列号，每次请求依次加一，如果一个请求的序列号早已用过，则认为无效。但是这个要用逻辑额外一个全局序列号，并不是特别方便。</p>
</li>
<li><p>HTTPS</p>
<p>​    终极解决方案了，HTTPS 在握手过程中会自动维护一个隐式序列号，解决了上面要自己维护序列号的问题。</p>
</li>
</ul>
<h2 id="2-token-被盗"><a href="#2-token-被盗" class="headerlink" title="2. token 被盗"></a>2. token 被盗</h2><p>因为 token 中包含了登陆状态，因此一旦 token 被盗，那么就会被人盗用身份。那么 token 针对被盗的防范措施整理如下：</p>
<ul>
<li>使用 HTTPS 传输：从传输层的角度解决问题</li>
<li>HTTPOnly：从存储层的角度解决问题，防止 XSS 攻击窃取 cookie，但是这种方案其实存在问题，因为这样 js 就无法读取 token 并把它加到 header 头中了。所以不开启 HTTPOnly 的话必须要额外注意防范 XSS 攻击。</li>
<li>在 token 中嵌入客户端指纹：通过客户端指纹，即使黑客盗取了你的 cookie，他也无法用你的 cookie 进行请求。</li>
<li>设置较短的 token 有效期：这样如果 token 被盗，只要超过一定时限就无法使用。</li>
</ul>
<h2 id="四、JWT-的其他问题"><a href="#四、JWT-的其他问题" class="headerlink" title="四、JWT 的其他问题"></a>四、JWT 的其他问题</h2><p>除了安全问题，JWT 还有许多其他需要考虑的问题。</p>
<ul>
<li><ol>
<li><p>注销问题</p>
<blockquote>
<p>因为 JWT 是无状态的，所以它的有效期完全由其本身决定，也就是说服务端无法让一个 token 失效。显然这是一个比较大的问题，对此也有诸多解决方案：</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>客户端主动注销</p>
<ul>
<li><p><strong>客户端直接删除存储 token 的 cookie</strong></p>
<p>这种方案最为简单，操作的结果是无论客户端还是服务端都没有这个 token，可问题是，这个 token 并没有真正不可使用，而是处于一个游离态。</p>
</li>
<li><p><strong>黑名单策略</strong></p>
<p>​    客户端携带要注销的 token 访问一个注销接口，服务端把 token 加入一个黑名单。</p>
<blockquote>
<p>此策略是否会出现黑名单过大的问题？</p>
<p>答案是不会，因为黑名单只需维护本身没有过期但又要使其无效的 token，过期的 token 就可以不用存在黑名单了。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>服务端主动注销 \ 用户修改密码</p>
<ul>
<li><p><strong>把 token 和 uuid 用 key-value 对存储在 redis</strong></p>
<p>这种方案看上去没问题，但是实际上，相当于自己实现了一次 cookie + session，JWT 就失去了『无状态』这一特性，从也会失去『无状态』特性带来的一系列的优点。</p>
</li>
<li><p><strong>让每个用户都有一个 secret</strong></p>
<p>​    前面讲到签发 token 的时候用到了 secret ，这种策略的思想就是让每个用户都有一个 secret，注销一个用户的时候修改其 secret，即可使其前面签发的 token 无法通过校验而失效。</p>
<p>​    这种策略上听上去不需要维护一个状态，但是实际上存在更大的问题。试想一下，第一种方案是通过 uuid 在已登录用户的 token 表中找到要注销的 token 注销。cookie + session 是通过 session_id 在已登录的用户的 session 表中找到其对应的 session 并删除来注销。而此方案是通过 uuid 在所有用户（而非已登录用户）中找到对于的 secret 修改来注销。这样看来会发现效率更低，因为查找范围更大了。</p>
</li>
<li><p><strong>预黑名单</strong></p>
<p>把要注销的用户的 uuid 和当前时间（TIME） 组成 key-value 对加入预黑名单，下次请求来时，若其 uuid 和黑名单中的对应，并且签发时间在 TIME 之前，则将其注销。这样查找范围就是未过期但又要注销的用户。并且在实现逻辑上这个预黑名单可以和签名的黑名单做到一起。</p>
<blockquote>
<p>关于黑名单策略的补充：</p>
<p>有人可能会觉得黑名单也是一种状态，用这种策略实现的 JWT 并不能算纯正的无状态。这种说法没错，但是考虑每次要检索的数据范围可以得到下面一个关系：</p>
<p>未过期但要提前注销的用户或 token 数 &lt; 所有已登录用户数 &lt; 所有用户数</p>
<p>此处的『 &lt; 』基本可以看成『远远小于』，所以黑名单策略虽然也算有状态，但是其维护的状态数也是特别小的。</p>
<p>可见 『黑名单』策略能够有效解决 JWT 的注销问题。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><ol start="2">
<li>续签问题</li>
</ol>
<p>session 可以自动续签，那 token 如何实现自动续签呢？我们先仔细分析一下在 web 和 app 环境中，token 分别如何续签。先具体分析 web 续签和 app 续签分别是什么样的具体需求。</p>
<ul>
<li><p>web</p>
<p>超过一段时间没有请求，需要重新登录，这个时间一般设置为 1-2 小时</p>
</li>
<li><p>app</p>
<p>超过一段较长的时间没有请求，需要重新登录，这个时间一般为 15-30 天</p>
</li>
<li><p><strong>那这个需求可以如何实现呢？</strong></p>
<ul>
<li><p><strong>方式一：</strong></p>
<blockquote>
<ul>
<li>服务端接管刷新</li>
<li>token 设置一个『过期时间』</li>
<li>token 过期后但是仍在『刷新时间』内时仍然可刷新</li>
<li>token 过期后超过『刷新时间』就不能再刷新，需重新登录</li>
</ul>
</blockquote>
<ul>
<li><p>web</p>
<p>假设一个 token 的签发时间为 12:00，需求为 2h 未进行请求就要重新登录。则过期时间为 1h，刷新时间为 3h。</p>
<p>那么在 12:00 - 13:00 其都是可以正常使用的，如果在 13:00 - 15:00 进行请求，服务端自动换一个新 token 给客户端，达成续签。</p>
<p>如果 13:00 -15:00 之间没有进行请求，而是在 15:00 之后进行的请求，那么判断过期，需重新登录。</p>
<blockquote>
<p>这样的话，最终的实现效果是：token 过期 2h 后需要重新登录 ，而不是 token 2h 未使用需要重新登录，导致的结果是，用户是 2 - 3h 未进行请求，需要重新登录。比设定的需求要多一个小时的不确定时间，但这也是没办法的办法了，至于会不会对业务造成影响，看具体需求吧，大多数的情况还是不会的。</p>
</blockquote>
</li>
<li><p>app</p>
<p>和 web 端类似，设置成更长的时间周期即可。</p>
<blockquote>
<p>对使用 Laravel 开发并使用 tymon/jwt-auth 这个插件的开发者，有个必须要注意的地方。</p>
</blockquote>
<p>此处进行 token 的刷新并不是通过 <code>refresh</code> 这个操作获得新 token，因为这样 token 在不断的刷新过程中会达到一个刷新时间的上限。而上面的逻辑是每次都新签发一个 token，只要不断签就能够一直使用下去。 然后这里的旧 token 放入黑名单，黑名单有效期设置为『刷新时间』—— 3h。</p>
<p>当然如果开发者觉得这样不断签就能够一直使用不太好，那就可以设置更长的刷新时间，用 <code>refresh</code> 操作来获取新 token，刷新时间保证每次登陆得到 token 后，即使每次及时续签，最终也不会超过刷新时间。</p>
<p>然后这里又会出现一个新坑：</p>
<p>如果刷新时间设置为 14 天，过期时间设置为 2h。</p>
<p>token A 在 『 &lt;= 14 天 』时刷新得到 token B，此时若再拿 token A 去请求刷新，肯定是不允许，否则 token 会出现『 1 变 N 』的问题，所以显然必须设置一个黑名单去放这些已过期但是又已经刷新过的 token。而这个黑名单的有效期范围应当为 token 的刷新期，即 14 天。然后你会发现对于每个用户每次登陆，需要维护的黑名单 token 数目最大可达 14 * 24 / 2 = 168 个，黑名单变得很大。</p>
<blockquote>
<p>所以，如果要使用 <code>refresh</code> 操作，刷新时间务必是过期时间的尽量小的倍数。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>方式二：</strong></p>
<blockquote>
<ul>
<li>每次请求 token 都进行一次刷新</li>
<li>token 设置一个过期时间</li>
<li>token 过期后无法再刷新</li>
<li>token 没必要设置刷新时间了</li>
</ul>
</blockquote>
<ul>
<li><p>web</p>
<p>假设一个 token 的签发时间为 12:00，需求为 2h 未进行请求即过期。则设置有效期 2h，不需要设置刷新期。那么每次请求都会把一个 token 换成一个新 token。如果 2h 没有进行请求，那么上一次请求的到的 token 就会过期，需要重新登录。同样是不断签就能一直使用下去。</p>
<p>如果想要和上面一样，不希望永久续签，则设置一个刷新时间即可。这个刷新时间不会导致进一步膨胀。</p>
</li>
<li><p>app</p>
<p>和 web 端类似，设置更长时间即可。</p>
<blockquote>
<p>然后又到了问题时间：</p>
<ol>
<li><p>每次都刷新 token，带来的性能影响如何？</p>
<p>以前每次请求，需要进行一次 token 签名校验，而现在是要签发一个新 token，进行的都是一次签名运算，那么运算量即从 n 变成 2n。</p>
<p>其次，每次刷新都要把旧 token 加入黑名单，会导致黑名单特别大，远远比方式一的设置刷新期大。</p>
</li>
<li><p>每次都刷新 token，并发请求时会不会因为 token 刷新而导致只有一个请求成功？</p>
<p>答案是确实会导致这个问题，怎么解决呢？设置一个宽限时间，每次 token 刷新后，原来逻辑应该是立刻不可用，现在设置一个宽限时间，让其在 n 秒之内仍然可用即可。</p>
</li>
</ol>
<p>总之，这种策略会导致花费的 CPU 运算翻倍，并导致巨大的黑名单，然后必须设置一个宽限时间以解决并发请求问题，至于宽限时间会不会带来安全问题，微乎其微吧。</p>
</blockquote>
</li>
</ul>
</li>
<li><h4 id="黑名单膨胀的解决方案"><a href="#黑名单膨胀的解决方案" class="headerlink" title="黑名单膨胀的解决方案"></a>黑名单膨胀的解决方案</h4><p>上面讲到，对于方式一【限定不能一直续签】，会导致巨大的黑名单，对于方式二，总会导致一个更加巨大的黑名单。那有没有解决方案呢？当然是有的。</p>
<p>我们可以这么想，既然一个 token 进行了刷新，那么签发时间在这次刷新之前的即可认为无效。于是，和上面的『预黑名单』策略类似，我刷新时不是把一个 token 加入黑名单，而是把 uuid-refresh_time 组成 key-vakue 对加入黑名单，这样针对每个用户的每次登陆，要存储到黑名单中的条目数就从 N 个变成了一个。</p>
<p>但是这样还要考虑一个问题：就是一个用户开两个浏览器，在不同的时刻在同一个系统都登陆了（假设业务允许），那么一个浏览器的 token 刷新就可能会导致另一个浏览器登陆失效。所以存储在黑名单中的 key-value 应该再加一个 key 以代表每次登陆，并且这个 key 要在 JWT 的载荷中随着刷新一直传承。</p>
<blockquote>
<p>基于以上的优化，黑名单的大小变成了：每个用户同时登陆的系统个数之和，就变的和 cookie + session 一样了。</p>
<p>比如，A 系统（假设 2h 过期时间，14 天刷新时间），你用一个浏览器登陆了你的账号，我用 Chrome 浏览器登陆了我的账号，然后我又用 QQ 浏览器再登陆我的账号，那么黑名单的大小就为 ： 1 + 2 = 3</p>
<p>而对于方式一【限定不能一直续签】，黑名单的大小（最大）：168 + 168 * 2</p>
<p>而对于方式二，黑名单的大小为：你在 2h 内请求的次数 x ，我在 Chrome 浏览器请求的次数 y，我在 QQ 浏览器请求的次数 z 之和，即：x + y + z</p>
</blockquote>
</li>
<li><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果要解决续签问题，方式一【可以一直续签】是个比较好的解决方案，虽然会带来一点小问题，但是并不会有太大的影响。方式二【限定不能一直续签】和 每次刷新会让黑名单的维护量和有状态差不多，但是有更高的安全性。</p>
</li>
</ul>
</li>
<li><h3 id="token-有没有必要每次刷新"><a href="#token-有没有必要每次刷新" class="headerlink" title="token 有没有必要每次刷新"></a>token 有没有必要每次刷新</h3><p>我们先列举每次刷新 token 的优缺点：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>能够实现续签</li>
<li>能够解决重放</li>
<li>更安全</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>双倍的 CPU 消耗</li>
<li>几乎和有状态一样的空间消耗</li>
<li>必须设置宽限时间解决并发问题</li>
</ul>
<p>上面讨论过，『续签』和『重放』都可以通过其他方式解决。只有『更安全』算半个痛点，为什么是半个痛点呢？因为如果采用 HTTPS 的话，那么盗取 token 的手段就只要以下几种办法：</p>
<ul>
<li>破解 HTTPS</li>
<li>直接从你电脑上手抄过去</li>
<li>XSS【前面说到为了能够让 js 读取，不能设置 HTTPOnly】</li>
</ul>
<p>只有第三种方法存在一点可能性。</p>
<blockquote>
<p>所以，要不要每次刷新，还是根据各位的具体业务情况进行选择吧。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="五、JWT-适合用来做什么"><a href="#五、JWT-适合用来做什么" class="headerlink" title="五、JWT 适合用来做什么"></a>五、JWT 适合用来做什么</h2><ol>
<li><h6 id="无状态的-RESTful-API"><a href="#无状态的-RESTful-API" class="headerlink" title="无状态的 RESTful API"></a>无状态的 RESTful API</h6><p>这个显然很适合。</p>
</li>
<li><h6 id="SSO-单点登录"><a href="#SSO-单点登录" class="headerlink" title="SSO 单点登录"></a>SSO 单点登录</h6><p>单点登录必须要实现的：</p>
<ul>
<li>会话管理：通过黑名单和预黑名单解决</li>
<li>续签：通过签名的解决方案解决</li>
</ul>
<blockquote>
<p>可见，对 JWT 部署一些额外逻辑（黑名单，续签管理）即可让 JWT 在大部分场景代替 cookie + session。</p>
</blockquote>
</li>
</ol>
<h2 id="六、JWT-与-Oauth2-0"><a href="#六、JWT-与-Oauth2-0" class="headerlink" title="六、JWT 与 Oauth2.0"></a>六、JWT 与 Oauth2.0</h2><p>Oauth 2.0 是干嘛的不再赘述，它与 JWT 其实并不是一个层面的东西。Oauth2.0 是一个方便的第三方授权规范，而 JWT 是一个 token 结构规范。只是 JWT 常用来登陆鉴权，而 Oauth2.0 在授权时也涉及到了登陆，所以就比较容易搞混。</p>
<p><strong>但是在此，我要说的是，Oauth 2.0 其实可以和 JWT 结合使用。</strong></p>
<p>以下是一个常见的 Oauth2.0 登陆返回：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span>:<span class="string">&quot;kag2geh11a3eh56e23hj&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;expires_in&quot;</span>:<span class="number">7200</span>,</span><br><span class="line">    <span class="attr">&quot;refresh_token&quot;</span>:<span class="string">&quot;jgko97cq4c8wn69j&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;scope&quot;</span>:<span class="string">&quot;SCOPE&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Oauth2.0 中，<code>access_token</code> 用来进行数据请求，而 <code>refresh_token</code> 用来刷新 <code>access_token</code>。每次刷新，上一个 access_token 就会失效，而 <code>access_token</code> 和 <code>refresh_token</code> 显然都没有记录任何状态，所以必须为服务端进行状态的维护。</p>
<p>把 JWT 和 Oauth2.0 结合后，可以得到这样的返回：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span>:<span class="string">&quot;xxx.yyy.zzz&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;expires_in&quot;</span>:<span class="number">7200</span>,</span><br><span class="line">    <span class="attr">&quot;refresh_token&quot;</span>:<span class="string">&quot;xxxxx.yyyyy.zzzzz&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;scope&quot;</span>:<span class="string">&quot;SCOPE&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行结合后有如下优势：</p>
<ul>
<li>Oauth2.0 的 token 也能够实现无状态（虽然也要用到黑名单）</li>
<li>Oauth2.0 的 token 也能够附带部分常用数据</li>
<li>前面讲到 JWT 续签，在需要限定不能一直续签的情形，可能会导致黑名单库膨胀，但是和 Oauth2.0 结合，通过 <code>refresh_token</code> 的机制，让黑名单库中 token 的有效期从 『刷新时间』又变回『过期时间』，从而解决了这个问题。</li>
</ul>
<h2 id="七、关于-token-十件必须知道的事"><a href="#七、关于-token-十件必须知道的事" class="headerlink" title="七、关于 token 十件必须知道的事"></a>七、关于 token 十件必须知道的事</h2><p>这是我从 Auth0 组织的这篇文章 <a target="_blank" rel="noopener" href="https://auth0.com/blog/ten-things-you-should-know-about-tokens-and-cookies/">10 Things You Should Know about Tokens</a> 整理过来的：</p>
<ol>
<li><p>Token 获取到后需要保存起来以便下次使用，可以选择存储在 localstorage /sessionstorage/cookie</p>
</li>
<li><p>Token 是包含有效期的，你必须部署一些逻辑来进行有效期的控制</p>
</li>
<li><p>localstorage /sessionstorage 的跨域限制较 cookie 更为严格，推荐使用 cookie</p>
</li>
<li><p>在你进行异步请求时，浏览器一般都会发送预检请求（option），后端应对此部署相应的逻辑</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1046663">为什么会有 OPTIONS 请求 - 云 + 社区 - 腾讯云</a></p>
</li>
<li><p>使用 cookie 可以轻松处理一个文件下载请求，但是 token 一般都是通过 XHR 方式进行请求的，所以你必须部署额外的逻辑。比如生成一个实时 ticket ，以 ticket 进行访问，然后校验，重定向，最后下载文件。</p>
</li>
<li><p>处理 XSS 比处理 CSRF 更容易（这一点我实在没看到他是什么个逻辑，大家可以去看看原文）</p>
</li>
<li><p>token 在每次请求时都会被编码到请求中，所以请注意 token 的大小，不要编码过多数据</p>
</li>
<li><p>如果在 token 中编码敏感信息，请对 token 进行加密</p>
</li>
<li><p>JSON Web Token 可以用于 Oauth2.0 的 Bearer Token 中，赋予 Oauth2.0 无状态的优势</p>
</li>
<li><p>Token 不是银弹，请根据实际业务需要进行选择</p>
</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ul>
<li><a target="_blank" rel="noopener" href="https://learnku.com/articles/10885/full-use-of-jwt">JWT 完整使用详解</a></li>
<li><a target="_blank" rel="noopener" href="https://learnku.com/articles/10889/detailed-implementation-of-jwt-extensions">JWT 扩展具体实现详解</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GivenSir</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.givensir.cn/posts/bde9a707ceca.html">https://blog.givensir.cn/posts/bde9a707ceca.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.givensir.cn" target="_blank">GivenSir`Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JWT/">JWT</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/d3913fbb65b6.html"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">一首红遍美国的小诗</div></div></a></div><div class="next-post pull-right"><a href="/posts/8a68e5e294ac.html"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RabbitMQ 安装</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By GivenSir</div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p><br /><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img class="icp-icon" src="https://xiabor.com/img/icp.png"><span>备案号：京ICP备17003555号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'trf5NhTAewo1cM71Ad5np1f7-gzGzoHsz',
      appKey: '6fICtj7zewtHufsaVzYk2yyr',
      placeholder: '都看到了，要不鼓励我亿下~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="(๑•̀ㅂ•́)و✧,ヾ(◍°∇°◍)ﾉﾞ,||ヽ(*￣▽￣*)ノミ|Ю,欢迎━(*｀∀´*)ノ亻!" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"jsonPath":"/live2dw/assets/hijiki.model.json"},"log":false});</script></body></html>